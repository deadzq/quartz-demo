#### 定时任务quartz简短介绍: <br>
触发器Trigger: 什么时候工作 <br>
任务Job: 做什么工作 <br>
调度器Scheduler: 搭配Trigger和Job <br>
实现Job接口,提供的execute,干具体的活儿 <br>
在Job中,其实由3个部分组成:<br>
jobDetail: 用于描述这个Job是做什么的 <br>
实现Job的类: 具体干活的 <br>
JobDataMap: 给Job提供参数用的 <br>
#### Job并发: <br>
默认的情况下,无论上一次任务是否结束或者完成,只要规定的时间到了,那么下一次就开始.<br>
有时候会做长时间的任务,比如数据库备份,这个时候就希望上一次备份成功结束之后,才开始下一次备份,即便是规定时间到了,也不能开始,<br>
因为这样很有可能造成数据库被锁死(几个线程同时备份数据库,引发无法预计的混乱). <br>
那么这种情况下,给数据库备份任务增加一个注解就好了: <br>
@DisallowConcurrentExecution <br>
中断:在业务上,有时需要中断任务,那么这个Job需要实现InterruptableJob接口 <br>
Trigger就是触发器的意思,用来指定什么时间开始触发,触发多少次,每隔多久触发一次.<br>
SimpleTrigger:可以方便的实现一系列的触发机制.比如多少时间后执行,重复几次等. <br>
CronTrigger是什么? <br>
Cron是Linux下的一个定时器,功能很强大,但是表达式更为复杂. <br>
CronTrigger就是用Cron表达式来安排触发时间和次数的.<br>
因为Cron特别复杂,如果以前接触过,可以按照Cron表达式来做触发器,没有接触过,还是用SimpleTrigger吧.<br>
0/2 * * * * ?  : 这个Cron表达式就表示每隔2秒执行一次. <br>
理解Cron: <br>
由7个部分组成,每个部分就如图所示分别对应秒,分,一直到年 <br>
星号(*): 可用在所有字段中,表示对应时间域的每一个时刻,例如,在分钟字段时,表示"每分钟". <br>
问号(?): 该字符只在日期和星期字段中使用,它通常指定为"无意义的值",相当于点位符; <br>
减号(-): 表达一个范围,如在小时字段中使用"10-12",则表示从10到12点,即10,11,12;<br>
逗号(,): 表达一个列表值,如在星期字段中使用"MON,WED,FRI",则表示星期一,星期三和星期五.<br>
Cron在线表达式 : http://cron.qqe2.com/ <br>
quartz Listener : <br>
Quartz的监听器有Job监听器,Trigger监听器,Scheduler监听器,对不同层面进行监控,实际业务用的<br>
较多的是Job监听器,用于监听器是否执行了,其它的用的相对较少,本知识主要讲解Job的.<br>
任务执行之前和执行之后都可以得到通知,这样的好处就是明确的知道,任务是否执行过了. <br>
对于业务要求严谨的系统,可以把这些信息保存到数据库里,将来回头查看哪些Job执行了,哪些Job没有执行. <br>
JDBCStore概念: <br>
默认情况,Quartz的触发器,调度,任务等信息都是放在内存中的,叫做RAMJobStore.<br>
好处是快速,坏处是一旦系统重启,那么信息就丢失了,就得全部从头来过.<br>
所以Quartz还提供了另一个方式,可以把这些信息存放在数据库做,叫做JobStoreTX.<br>
好处是就算系统重启了,目前运行到第几次了这些信息都是存放在数据库中的,<br>
那么就可以继续原来的步伐把计划任务无缝地继续做下去.<br>
坏处就是性能上比内存慢一些,毕竟数据库读取总是要慢一些的.<br>
http://how2j.cn/k/quartz/quartz-jdbcstore/1713.html#nowhere  <br>
Quartz集群: <br>
所谓Quartz集群,是指在基于数据库存储Quartz调度信息的基础上,<br>
有多个一模一样的Quartz应用在运行,当某一个Quartz应用重启或发生问题时<br>
其它Quartz应用会借助数据库这个桥梁探知到它不行了,从而接手把该进行的Job调度工作<br>
进行下去.以这种方式保证任务调度的高可用性,即在发生异常重启等情况下,调度信息依然连贯性<br>
地进行下去,就好像Quartz应用从来没有中断过似的.<br>
http://how2j.cn/k/quartz/quartz-cluster/1715.html <br>





